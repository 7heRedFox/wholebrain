


acronym.from.id<-function(x){
	unlist(lapply(x, function(y){if(length(which(ontology$id ==y))!=0){return(as.character(ontology$acronym[which(ontology$id ==y)]))}else{return(NA)} }))
}

id.from.acronym <-function(x){
	unlist(lapply(x, function(y){if(length(which(ontology$acronym ==y))!=0){return(ontology$id[which(ontology$acronym ==y)])}else{return(NA)} }))
}

name.from.acronym<-function(x){
	unlist(lapply(x, function(y){if(length(which(ontology$acronym ==y))!=0){return(ontology$name[which(ontology$acronym ==y)])}else{return(NA)} }))
}

name.from.id<-function(x){
	unlist(lapply(x, function(y){if(length(which(ontology$id ==y))!=0){return(ontology$name[which(ontology$id ==y)])}else{return(NA)} }))
}

color.from.id<-function(x){
	unlist(lapply(x, function(y){if(length(which(ontology$id ==y))!=0){return(ontology$allen.color[which(ontology$id ==y)])}else{return(NA)} }))
}

color.from.acronym<-function(x){
	unlist(lapply(x, function(y){if(length(which(ontology$acronym ==y))!=0){return(as.character(ontology$allen.color[which(ontology$acronym ==y)]))}else{return(NA)} }))
}

get.acronym.parent<-function(x){
	ids<-unlist(lapply(x, function(y){if(length(which(ontology$acronym ==y))!=0){if(y=='root'){return('997')}else{return(ontology$parent[which(ontology$acronym ==y)])}}else{return(NA)} }))
	return(acronym.from.id(ids))
}

get.acronym.child<-function(x){
	ids<-unlist(lapply(x, function(y){if(length(which(ontology$parent == ontology$id[which(ontology$acronym == y)]))!=0){if(y=='root'){return('997')}else{return(ontology$id[which(ontology$parent == ontology$id[which(ontology$acronym == y)])])}}else{return(NA)} }))
	return(acronym.from.id(ids))
}

get.sup.structure<-function(x, matching.string=c('CTX','CNU','IB','MB','HB','grey','root','VS','fiber tracts')){
	
	if(x%in%matching.string){
		return(x)
	}
	tmp<-get.acronym.parent(x)
	if((tmp%in%matching.string)){
    	tmp<-x  
	}
	tmp2<-tmp
	while(!(tmp%in% matching.string) ){
    	tmp2<-tmp
    	tmp<-get.acronym.parent(tmp)
    }
	if(tmp=='root'|tmp=='grey'|tmp=='CH'){
		return(tmp2)
	}else{
		return(tmp)
	}
}

get.sub.structure<-function(x){
	tmp<-get.acronym.child(x)
	if(sum(is.na(tmp)/length(tmp))!=0){
    	tmp<-x
    	return(tmp)  
	}
	tmp2<-tmp
	for(i in tmp){
		tmp2<-append(tmp2, get.sub.structure(i) )
	}
	return(tmp2)
}

remove.whitematter<-function(dataset){
	dataset<-dataset[-which(dataset$acronym%in%c('grey', 'fibertracts')),]
	return(dataset)
}

get.vector.intensity<-function(input, x, y){
	file <- as.character(input)
    ## check for existence
    if(!file.exists(file)){
      stop(file, ", file not found")
      return(NULL)
  	}
    file <- path.expand(file)

	intensity<-.Call("getVectorIntensity", file, as.integer(x), as.integer(y))
	return(intensity)
}

get.pixel.intensity<-function(input, x, y, type='SNR', roi= 9,  background=40){
	file <- as.character(input)
    ## check for existence
    if(!file.exists(file)){
      stop(file, ", file not found")
      return(NULL)
  	}
    file <- path.expand(file)
    if(type=='SNR'){
    	type=2
    }else{
    	type=1
    }
	intensity<-.Call("getPixelIntensity", file, as.integer(x), as.integer(y), type, roi, background)
	return(intensity)
}

get.range<-function(input){
	file <- as.character(input)
    ## check for existence
    if(!file.exists(file)){
      stop(file, ", file not found")
      return(NULL)
  	}
    file <- path.expand(file)
 
	maxmin<-.Call("getMaxMin", file)
	return(maxmin)
}



#' Flip cells to the ipsilateral side
#'
#' Flips the cells to the right hemisphere.
#' @param dataset a data frame generated by inspect.registration() or get.cell.ids().
#' @param right.hemisphere boolean, if TRUE then cells will be flipped to right side.
#' @examples
#' dataset<-reflect.cells(dataset)
reflect.cells<-function(dataset){
	if (length(table(dataset$right.hemisphere)) > 
                  1){ 
                  if (table(dataset$right.hemisphere)[2] < table(dataset$right.hemisphere)[1]) {
                    dataset$ML <- -dataset$ML
                  }
                  }
                  return(dataset)
}


#' Get cell counts for a specific Region of Interest (ROI).
#'
#' Get cell counts for a specific Region of Interest (ROI) in tidy format.
#' @param dataset a data frame generated by inspect.registration() or get.cell.ids().
#' @param rois a character vector with acronyms for brain regions you want.
#' @examples
#' #get cell position and identity
#' dataset<-get.cell.ids(regi, seg)
#' #extract roi counts
#' data<-roi.cell.count(dataset, rois=c('MO','TH'))
roi.cell.count<-function(dataset, rois=c('MO','TH')){
	cell.counts<-table(dataset$acronym, dataset$animal)
	regions<-get.sub.structure(rois[1])
	regions<-which(row.names(cell.counts)%in%regions)
	if(length(dim(cell.counts[regions,]))>1){
		roi.data<-colSums(cell.counts[regions,])
	}else{
		roi.data<-cell.counts[regions,]
	}
	for(i in rois[-1]){
		cell.counts<-table(dataset$acronym, dataset$animal)
		regions<-get.sub.structure(i)
		regions<-which(row.names(cell.counts)%in%regions)
		if(length(dim(cell.counts[regions,]))>1){
			roi.data<-rbind(roi.data, colSums(cell.counts[regions,]))
		}else{
			roi.data<-rbind(roi.data, cell.counts[regions,])
		}
		
	}
	
	roi.data <-data.frame(acronym=rep(rois, ncol(roi.data)), animal= rep(colnames(roi.data), each=nrow(roi.data)), cell.count = as.numeric(roi.data) )

	return(roi.data)	
}

summary.func <- function(x, col){
    c(mean = mean(x[[col]], na.rm=TRUE),
      err = se(x[[col]], na.rm=TRUE))
  }


#' Summary mean and dispersion
#'
#' Function to calculate the mean and the dispersion for each group
#' @param a data frame
#' @param varname the name of a column containing the variable to be summariezed
#' @param groupnamesvector of column names to be used as grouping variables
#' @examples
#' df <- data.summary(data, varname="cell.count", groupnames=c("genotype", "dose"))
data.summary <- function(data, varname, groupnames){
  
  data_sum<-ddply(data, groupnames, .fun=summary.func,
                  varname)
  data_sum <- rename(data_sum, c("mean" = varname))
 return(data_sum)
}

#' Add group variable
#'
#' Function to add a group variable such as genotype or experimental group based on animal ID.
#' @param data a data frame
#' @param subjectID a character vector 
#' @param group a character vector ordered accordin to subjectID which indicates what group.
#' @examples
#' df <- add.group(data, subjectID=c('R0057A317','R0057A319','R0057A322','R0057A335','R0057A341','R0057A342','R0057A345','R0057A346' 'R0057A347' 'R0057A349','R0057A350','R0057A355','R0057A358','R0057A360','R0057A361', 'R0057A365','R0057A371','R0057A375'), group=c("genotype", "dose"))
add.group <- function(data, subjectID, group){

  data$group<-as.character(data$animal)
  for(i in 1:length(subjectID)){
  	data$group[which(as.character(data$group)==subjectID[i])]<-group[i]
  }	

 return(data)
}

#' Convert to grayscale
#'
#' Get the contours of a binary segmented image
#' @param input input a character vector consisting of the full path name to 16-bit raw tif image files.
#' @param coordinate matching coordinates in the main plane to be registered to (in millimeters).
#' @param plane the main plane to register too: "coronal", "sagital", "".
#' @param brain.threshold a integer value, which determien sthe segmentation of the brain slice.
#' @param verbose boolean value. If true diagnostic output is written to the R console. Deafult is true.
#' @examples
#' #path to image
#' image<-'/Volumes/microscope/animal001/slide001/section001.tif'
#' #register the image
#' registration(image, AP=1.05, brain.threshold=220)
rgb2gray<-function(input, verbose=TRUE, savefilename=TRUE, invert=TRUE){
    file <- as.character(input)
    ## check for existence
    if(!file.exists(file))
      stop(file, ", file not found")
    file <- path.expand(file)
    
     if(savefilename==TRUE){
      pos <- regexpr("\\.([[:alnum:]]+)$", basename(file))	
      filename<-ifelse(pos > -1L, substring(basename(file), 1, pos - 1L), "")
      savefilename<-paste(getwd(),'/grayscale_',filename,'.tif', sep='')
     }

    a<-.Call("rgbTogray", file, as.integer(verbose), savefilename, as.integer(invert))
    
    return(savefilename)
}

invert.img<-function(input, verbose=TRUE, savefilename=TRUE){
    file <- as.character(input)
    ## check for existence
    if(!file.exists(file))
      stop(file, ", file not found")
    file <- path.expand(file)
    
     if(savefilename==TRUE){
      pos <- regexpr("\\.([[:alnum:]]+)$", basename(file))	
      filename<-ifelse(pos > -1L, substring(basename(file), 1, pos - 1L), "")
      savefilename<-paste(getwd(),'/inverted_',filename,'.tif', sep='')
     }

    a<-.Call("invertImg", file, as.integer(verbose), savefilename)
    
    return(savefilename)
}

morph<-function(input, element = 0, size = 0, operator = 'tophat', save.as.8bit = TRUE, verbose = TRUE, savefilename=TRUE) {
	file <- as.character(input)
    ## check for existence
    if(!file.exists(file))
      stop(file, ", file not found")
    file <- path.expand(file)
    #"Operator:\n 0: Opening - 1: Closing \n 2: Gradient - 3: Top Hat \n 4: Black Hat"
    if(operator=='tophat'){
    	morphOperator<-3
    }
    if(operator=='open'){
    	morphOperator<-0
    }
    if(operator=='close'){
    	morphOperator<-1
    }
    if(operator=='gradient'){
    	morphOperator<-2
    }
    if(operator=='blackhat'){
    	morphOperator<-4
    }

    if(savefilename==TRUE){
      pos <- regexpr("\\.([[:alnum:]]+)$", basename(file))	
      filename<-ifelse(pos > -1L, substring(basename(file), 1, pos - 1L), "")
      savefilename<-paste(getwd(),'/',operator,'_',filename,'.tif', sep='')
     }

     a<-.Call("morphologyEx", input, element, size, morphOperator, as.integer(save.as.8bit), as.integer(verbose), savefilename)
     return(savefilename)
}

make.movie<-function(directory){
	
}

legacy<-function(dataset){

}

pax.to.allen<-function(paxinos){
 	round(214+(20-(paxinos*1000))/25)
}

read.brains<-function(filenames, animalID=NULL){

data<-read.table(filenames[1], sep=',', header=TRUE, fill=TRUE)
if(!is.null(animalID)){
data$animal<-animalID[1]
}
for(i in 1:length(filenames)){
	data.tmp<-read.table(filenames[i], sep=',', header=TRUE, fill=TRUE)
	if(!is.null(animalID)){
		data.tmp$animal<-animalID[i]
	}
	data<-rbind(data, data.tmp)
}
return(data)
}

check.progress<-function(barWidth, progress, stages, message, timing){
	cat("  [")
     	pos = round(barWidth * progress);
    	for(p in seq(0,barWidth-1)) {
        	if(p < pos){ 
        		cat("=")
   			}
        	else{if (p == pos){
        		cat(">")
    		}
    		else{
    			cat(" ")
    		}
    		}	
    	}
    	message.new<-paste("] ", round(progress * 100.0), "% | ",message," | time left: ", timing," |\r", sep='')
    	paste(message.new, paste(rep(' ', nchar(message.new)), collapse=' '), sep='')
    	cat(message.new)
    	Sys.sleep(.05)
    	progress <- progress + 1/(stages);
    	flush.console()
    	process.events()
    	return(progress)
}


stitch.animal<-function(folder, rotate=0, FFC=TRUE, web.map=TRUE, start.at=1, dont.run=NULL){
	all.section.folder<-list.dirs(folder, recursive=FALSE, full.names=FALSE)
	remove<-c(which(substr(all.section.folder, 1,6)%in%c('output','stitch')),which(substr(all.section.folder, 1,3)%in%c('FFC','Web')))
	if(length(remove)>0){
		all.section.folder<-all.section.folder[-remove]
	}
	if(!is.null(dont.run)){
		all.section.folder<-all.section.folder[-dont.run]
	}

	if(start.at>1){
		if(length(start.at)>1){
				all.section.folder<-all.section.folder[start.at[1]:start.at[2]]
			}else{
				all.section.folder<-all.section.folder[start.at:length(all.section.folder)]
			}
	}
	barWidth = 50;
   progress = 0.0;
   processing.steps<-length(all.section.folder)*(2+FFC+web.map)
   elapsed.time<-'?'
   elapsed.time.series<-numeric()

   if(length(rotate)==1){rotate<-rep(rotate, length(all.section.folder))}else{
   			rotate<-rotate[start.at:length(rotate)]
   }
   section.folder<-''
   images<-''
	for(i in all.section.folder){
		ptm <- proc.time()
		section.folder<-paste(folder,i, sep='/')
		progress<-check.progress(barWidth, progress, processing.steps, paste('Flat-field correction on:',i,'| image',which(all.section.folder==i),'of',length(all.section.folder)), elapsed.time )

		#get images 
		images<-get.images(section.folder)
		#order them
		index<-basename(images)
		index<-gsub("[A-z \\.\\(\\)]","",index)
		index<-gsub("[- \\.\\(\\)]","",index)
		index<-as.numeric(index)
		index<-order(index)
		images<-images[index]
		#Flat-field correction
		if(FFC){
			flat.field.correction(images, verbose=FALSE)
			progress<-check.progress(barWidth, progress, processing.steps, paste('Stitching:',i,'| image',which(all.section.folder==i),'of',length(all.section.folder)), elapsed.time )

			FFC.folder<-paste('FFC',basename(section.folder), sep='_')
			FFC.folder<-paste(folder, FFC.folder, sep='/')
			images<-get.images(FFC.folder)
			images<-images[index]
			stitched<-paste('stitched_FFC',basename(section.folder), sep='_')
			stitched<-paste(folder, stitched, sep='/')
		}else{
			stitched<-paste('stitched',basename(section.folder), sep='_')
			stitched<-paste(folder, stitched, sep='/')
		}		
		
		#stitch
		stitch(images, rotate=rotate[which(all.section.folder==i)], verbose=FALSE) 
		progress<-check.progress(barWidth, progress, processing.steps, paste('Web output:',i,'| image',which(all.section.folder==i),'of',length(all.section.folder)), elapsed.time )

		if(web.map){
			defaultwd<-getwd()
			setwd(folder)
			stitched<-get.images(stitched)
			makewebmap(stitched, verbose=FALSE)
			progress<-check.progress(barWidth, progress, processing.steps, paste('DONE:',i,'| image',which(all.section.folder==i),'of',length(all.section.folder)), elapsed.time )

			setwd(defaultwd)
		}
		elapsed.time.series<- append(elapsed.time.series , round( (proc.time()[3] - ptm[3])*(length(all.section.folder)-which(all.section.folder==i)) ) )
		elapsed.time<-mean(elapsed.time.series)
		elapsed.time<- format(.POSIXct(elapsed.time,tz="GMT"), "%H:%M:%S")
	}
	progress<-check.progress(barWidth, progress, processing.steps, ' FINISHED ', elapsed.time )

}


stitch.experiment<-function(folder){
	all.animals<-dir(folder)
	for(i in all.animals){
		section.folder<-paste(folder,i, sep='/')
		stitch.animal(section.folder)
	}
}


spreadsheet.animal<-function(folder, file, sep=','){
	filename<-list.dirs(folder, recursive=FALSE, full.names=FALSE)
	sectionname<-basename(filename)
	filename<-filename[substr(sectionname, 1, nchar('stitched_FFC'))=='stitched_FFC']
	sectionname<-sectionname[substr(sectionname, 1, nchar('stitched_FFC'))=='stitched_FFC']

	colNames<-c("filename", "section", "rotation", "Min", "Max", "soma.area", "eccentricity", "")

	data<-data.frame(matrix(rep(0, ncol(data)*length(sectionname)), ncol=length(colNames) ) )

	names(data)<-colNames

	data$filename<-filename
	data$section<-sectionname

	write.table(data, file=file, sep=sep, row.names=FALSE)
	return(data)
}
